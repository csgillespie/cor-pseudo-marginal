source("R/helper.R")

############################
#Modified innovation scheme#
############################
#Function to obtain Brownian innovations from a bridge x generated by the modified diffusion bridge construct
getW = function(x, deltat, inter, sim) {
  n = inter / deltat
  vec = rep(0, length = (n+1))
  xT = x[n+1]
  for(i in 1:(n-1)) {
    tm = inter - (i-1) * deltat
    t = inter - i*deltat
    vec[i+1]=(x[i+1] - x[i] - (xT - x[i]) * deltat / tm)/ (sim$diffusion(x[i])*sqrt(t / tm))
  }
  return(vec)
}
#Function to use Briwnian innovations to generate a bridge (deterministically)
useW = function(brown, mid_points, deltat, inter, sim) {
  n = inter/deltat
  vec = numeric(n+1)
  vec[c(1, n + 1)] = mid_points
  for(i in 1:(n-1)) {
    tm = inter - (i-1)*deltat
    t = inter - i*deltat
    vec[i+1] = vec[i] + (mid_points[2] - vec[i]) * deltat / tm +
      sim$diffusion(vec[i]) * sqrt(t / tm) * brown[i+1]
    vec[i + 1] = max(vec[i+1], 1e-5)
  }
  return(vec)
}

#Function to implement modified innovation scheme
#sigma=tuning matrix for random walk update
#inter=inter observation time

mis = function(sde, obs, sigma, log_prior, pars_init,
               deltat, inter, iters = 1000

) {
  n = length(obs) #no. data points
  ntot = (n-1)/deltat + 1  #total no. of observed and latent data points
  cur = log(pars_init) #current param value (log-scale)
  sim_cur = sde(exp(cur))
  
  
  # Store log parameter values
  theta_mat = matrix(0, ncol = length(cur), nrow = iters)
  theta_mat[1, ] = cur
  
  # Store process
  latent_mat = matrix(0, ncol = ntot, nrow = iters)
  latent_mat[1, ] = c(rep(obs[-length(obs)], each = inter/deltat), obs[length(obs)])
  
  latent_prop = numeric(ntot)
  count = 0
  
  # Helper vectors used for extraction of inter-observation times
  stride = inter/deltat
  size = seq(1, ntot, by = stride)
  
  for (i in 2:iters) {
    latent_cur = latent_mat[i - 1,]
    #Update parameters
    #Propose candidate param value
    prop = rmvn(cur, sigma)
    q_cur = q_prop = 0
    sim_prop = sde(exp(prop))
    for(j in seq_len(n-1)) {
      mid = size[j]:size[j+1]
      brownInt = getW(latent_cur[mid], deltat, inter, sim_cur)
      #Use the brownian increments with exp(can) to get path deterministically
      latent_prop[mid] = useW(brownInt, mid_points = obs[j:(j+1)], deltat, inter, sim_prop)
      q_cur = q_cur + Qdensity(latent_cur[mid], deltat, inter, sim_cur)
      q_prop = q_prop + Qdensity(latent_prop[mid], deltat, inter, sim_prop)
    }
    
    #Calculate likelihood at proposed and current values
    accept_prob = EMdensity(latent_prop, deltat, (n-1) * inter, sim = sim_prop) +
      log_prior(prop) -
      EMdensity(latent_cur, deltat, (n-1) * inter, sim = sim_cur) -
      log_prior(cur) +
      q_cur - q_prop
    
    #Store in theta_mat
    if(log(runif(1)) < accept_prob) {
      cur = prop  #with correct probability, chain moves, store updated log-likelihood
      latent_cur = latent_prop
      sim_cur = sim_prop
      count = count+1  #track no. theta acceptances
    }
    theta_mat[i,] = cur #store
    latent_mat[i,] = latent_cur  #store
    
    # Update latent process between observations
    for(j in seq_len(n-1)) {
      mid = size[j]:size[j+1]
      
      #Propose a path
      latent_prop = bridgeSimQ(obs[j:(j+1)], deltat, inter, sim_cur)
      accept_prob = EMdensity(latent_prop, deltat, inter, sim_cur) -
        EMdensity(latent_cur[mid], deltat, inter, sim_cur) +
        Qdensity(latent_cur[mid], deltat, inter, sim_cur) -
        Qdensity(latent_prop, deltat, inter, sim_cur)
      
      # Accept/Reject
      if(log(runif(1)) < accept_prob) {
        latent_cur[mid] = latent_prop
      }
    }
    latent_mat[i, ] = latent_cur #store
  }
  message(signif(count/(iters-1), 3) * 100)
  #return(list(theta = theta_mat, latent = latent_mat)) #Return posterior samples of (log) parameters and latent path
  return(theta_mat)
}
